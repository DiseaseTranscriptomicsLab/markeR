#' FDR Simulation Plot
#'
#' This function simulates false discovery rates (FDR) by generating simulated gene signatures and comparing
#' the observed Cohen's d values of the original signatures to those from simulations. Three scoring methods
#' (ssGSEA, logmedian, ranking) are used to compute the metrics, and the results are visualized as violin plots
#' with overlaid observed values.
#'
#' @param counts A data frame or matrix of gene expression counts.
#' @param metadata A data frame containing sample metadata.
#' @param original_signatures A named list of gene signatures. Each element can be either a vector of gene names
#' (implying unidirectionality) or a data frame with columns `"Gene"` and `"Signal"`.
#' @param gene_list A character vector of gene names from which simulated signatures are generated by sampling.
#' @param number_of_sims Integer. The number of simulated signatures to generate per original signature.
#' @param title_for_plot Character. A prefix for the plot title. The final title will also include the signature name.
#' @param widthTitle Numeric. Maximum width used by the helper function \code{wrap_title} for wrapping titles (default: 10).
#' @param titlesize Numeric. Font size for the plot title (default: 12).
#' @param y_limits Numeric vector of length 2. Limits for the y-axis in the plots (default: NULL).
#' @param legend_nrow Integer. Number of rows to be used for the legend layout (default: NULL).
#' @param pointSize Numeric. Size of points in the plot (default: 2).
#' @param xlab Character. Label for the x-axis (default: NULL).
#' @param labsize Numeric. Font size for axis labels (default: 10).
#' @param GroupingVariable Category in which variables should be grouped. This will be used for Cohen's D and PValue Calculations.
#'
#' @return This function prints a combined \code{ggplot} object containing the simulation plots for all gene signatures.
#' It returns the combined plot invisibly.
#'
#' @details
#' The function first computes the observed Cohen's d and associated p-values for all original signatures using the
#' \code{CohenD_allConditions} function. For each signature, a number of simulated signatures are generated by sampling
#' genes from \code{gene_list}. For each simulation, Cohen's d and p-values are calculated using the same grouping
#' variable. The simulation results are restructured into a long-format data frame for
#' plotting. A violin plot is created for each signature, displaying the distribution of simulated Cohen's d values for
#' each method. A dashed vertical line indicates the 95th percentile (top 5% threshold) of the simulated distribution, and
#' the observed value is overlaid as a point, with significance indicated by different point shapes.
#'
#' @examples
#' \dontrun{
#'   # Example usage:
#'   # Assume `expr_data` is a data frame with gene expression counts,
#'   # `meta` is a data frame with sample metadata,
#'   # `orig_sigs` is a named list of gene signatures,
#'   # and `genes` is a character vector of gene names.
#'
#'   FDR_Simulation(data = expr_data,
#'                  metadata = meta,
#'                  original_signatures = orig_sigs,
#'                  gene_list = genes,
#'                  number_of_sims = 100,
#'                  title_for_plot = "FDR Simulation Plot")
#' }
#'
#' @import ggplot2
#' @import ggpubr
#' @export
#'
FDR_Simulation <- function(data, metadata, original_signatures, GroupingVariable, gene_list, number_of_sims, title_for_plot,
                           widthTitle = 10, titlesize = 12, y_limits = NULL, legend_nrow = NULL, pointSize = 2, xlab = NULL, labsize = 10) {

  # Compute observed Cohen's D for all original signatures
  results <- CohenD_allConditions(
    data = data,
    metadata = metadata,
    gene_sets = original_signatures,
    variable = GroupingVariable
  )

  methods <- c("ssGSEA", "logmedian", "ranking")

  # Create a list to store plots (one per signature)
  plot_list <- list()
  signature_names <- names(results)

  for (sig in signature_names) {
    # Use the current signature as the base for simulation
    cur_sig <- original_signatures[[sig]]

    # If signature is just a vector, we assume unidirectionality
    if (is.vector(cur_sig)) {
      cur_sig <- data.frame(Gene = cur_sig, Signal = 1)
    }

    else {
      colnames(cur_sig) <- c("Gene", "Signal")
    }


    # Generate simulated signatures based on the current signature
    simulatedsigs <- list()
    for (sim in 1:number_of_sims) {
      cur_model_sig <- cur_sig  # copy the current signature
      cur_model_sig$Gene <- sample(gene_list, nrow(cur_sig))  # simulate by sampling genes
      simulatedsigs[[paste0("sim", sim)]] <- cur_model_sig
    }

    results2 <- CohenD_allConditions(
      data = data,
      metadata = metadata,
      gene_sets = simulatedsigs,
      variable = GroupingVariable
    )

    # Restructure simulation results into a list (one data frame per method)
    restructured <- lapply(methods, function(m) {
      data.frame(
        CohensD = sapply(results2, function(sim) sim$CohenD[m, 1]),
        Pval    = sapply(results2, function(sim) sim$PValue[m, 1])
      )
    })
    names(restructured) <- methods

    # Combine simulation data into one long-format data frame
    sim_data <- do.call(rbind, lapply(methods, function(m) {
      df <- restructured[[m]]
      df$Method <- m
      df$Shape <- ifelse(df$Pval < 0.05, "Significant", "Not Significant")
      df
    }))
    # Set Method as a factor to control order in the plot
    sim_data$Method <- factor(sim_data$Method, levels = methods)

    # Compute only the 95th percentile (top 5% threshold) for each method
    q_data <- do.call(rbind, lapply(methods, function(m) {
      cd_vals <- sim_data$CohensD[sim_data$Method == m]
      data.frame(
        Method = m,
        q_high = as.numeric(quantile(cd_vals, 0.95, na.rm = TRUE))
      )
    }))
    q_data$Method <- factor(q_data$Method, levels = methods)
    # For drawing a segment, compute a numeric y-position for each method
    q_data$ypos <- as.numeric(q_data$Method)

    # Extract observed data for the current signature
    obs_data <- data.frame(
      Method = methods,
      CohensD = c(
        results[[sig]]$CohenD["ssGSEA", 1],
        results[[sig]]$CohenD["logmedian", 1],
        results[[sig]]$CohenD["ranking", 1]
      ),
      PValue = c(
        results[[sig]]$PValue["ssGSEA", 1],
        results[[sig]]$PValue["logmedian", 1],
        results[[sig]]$PValue["ranking", 1]
      ),
      stringsAsFactors = FALSE
    )
    obs_data$Method <- factor(obs_data$Method, levels = methods)
    obs_data$Shape <- ifelse(obs_data$PValue < 0.05, "Significant", "Not Significant")

    # Build the plot for the current signature
    p <- ggplot2::ggplot() +
      # Violin for simulation distribution (by method)
      ggplot2::geom_violin(data = sim_data, aes(x = CohensD, y = Method), fill = "lightblue", color = "black", alpha = 0.5) +
      # Jittered simulation points (with shape based on significance)
      ggplot2::geom_jitter(data = sim_data, aes(x = CohensD, y = Method, shape = Shape), width = 0.1, size = pointSize, alpha = 0.5) +
      # Add a vertical dashed segment at the 95th percentile for each method
      ggplot2::geom_segment(data = q_data,
                            aes(x = q_high, xend = q_high,
                                y = ypos - 0.3, yend = ypos + 0.3),
                            linetype = "dashed", color = "red") +
      # Overlay the observed value (colored by method and shaped by significance)
      ggplot2::geom_point(data = obs_data, aes(x = CohensD, y = Method, color = Method, shape = Shape), size = 3) +
      ggplot2::scale_shape_manual(values = c("Significant" = 17, "Not Significant" = 16)) +
      ggplot2::labs(title = paste(title_for_plot, "\nSignature:", sig),
                    x = "Cohen's D", y = "Metric") +
      ggplot2::theme_bw() +
      ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = titlesize),
                     axis.text = ggplot2::element_text(size = labsize))

    plot_list[[sig]] <- p
  }

  # Arrange all signature plots in a grid.
  n_sig <- length(plot_list)
  ncol <- ceiling(sqrt(n_sig))
  nrow <- ceiling(n_sig / ncol)

  combined_plots <- ggpubr::ggarrange(plotlist = plot_list, ncol = ncol, nrow = nrow, common.legend = TRUE, legend = "bottom")

  print(combined_plots)
}
